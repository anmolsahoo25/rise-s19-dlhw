//
// Generated by Bluespec Compiler, version 2018.10.beta1 (build e1df8052c, 2018-10-17)
//
// On Thu May 30 18:51:46 IST 2019
//
//
// Ports:
// Name                         I/O  size props
// RDY_putvalue1                  O     1 const
// RDY_putvalue2                  O     1 const
// get                            O    32
// RDY_get                        O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// putvalue1_x                    I    32
// putvalue2_y                    I    32
// EN_putvalue1                   I     1
// EN_putvalue2                   I     1
// EN_get                         I     1 unused
//
// Combinational paths from inputs to outputs:
//   (putvalue1_x, putvalue2_y, EN_putvalue1, EN_putvalue2) -> get
//   (EN_putvalue1, EN_putvalue2) -> RDY_get
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkArbiter(CLK,
		 RST_N,

		 putvalue1_x,
		 EN_putvalue1,
		 RDY_putvalue1,

		 putvalue2_y,
		 EN_putvalue2,
		 RDY_putvalue2,

		 EN_get,
		 get,
		 RDY_get);
  input  CLK;
  input  RST_N;

  // action method putvalue1
  input  [31 : 0] putvalue1_x;
  input  EN_putvalue1;
  output RDY_putvalue1;

  // action method putvalue2
  input  [31 : 0] putvalue2_y;
  input  EN_putvalue2;
  output RDY_putvalue2;

  // actionvalue method get
  input  EN_get;
  output [31 : 0] get;
  output RDY_get;

  // signals for module outputs
  reg [31 : 0] get;
  wire RDY_get, RDY_putvalue1, RDY_putvalue2;

  // register toggle
  reg toggle;
  wire toggle$D_IN, toggle$EN;

  // rule scheduling signals
  wire WILL_FIRE_RL_rl_p1, WILL_FIRE_RL_rl_p2, WILL_FIRE_RL_rl_p3;

  // inputs to muxes for submodule ports
  wire [31 : 0] MUX_dataout$wset_1__VAL_3;

  // action method putvalue1
  assign RDY_putvalue1 = 1'd1 ;

  // action method putvalue2
  assign RDY_putvalue2 = 1'd1 ;

  // actionvalue method get
  always@(WILL_FIRE_RL_rl_p1 or
	  putvalue1_x or
	  WILL_FIRE_RL_rl_p2 or
	  putvalue2_y or WILL_FIRE_RL_rl_p3 or MUX_dataout$wset_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_rl_p1: get = putvalue1_x;
      WILL_FIRE_RL_rl_p2: get = putvalue2_y;
      WILL_FIRE_RL_rl_p3: get = MUX_dataout$wset_1__VAL_3;
      default: get = 32'hAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign RDY_get =
	     WILL_FIRE_RL_rl_p1 || WILL_FIRE_RL_rl_p2 || WILL_FIRE_RL_rl_p3 ;

  // rule RL_rl_p1
  assign WILL_FIRE_RL_rl_p1 =
	     EN_putvalue1 && !WILL_FIRE_RL_rl_p2 && !WILL_FIRE_RL_rl_p3 ;

  // rule RL_rl_p2
  assign WILL_FIRE_RL_rl_p2 = EN_putvalue2 && !WILL_FIRE_RL_rl_p3 ;

  // rule RL_rl_p3
  assign WILL_FIRE_RL_rl_p3 = EN_putvalue2 && EN_putvalue1 ;

  // inputs to muxes for submodule ports
  assign MUX_dataout$wset_1__VAL_3 = toggle ? putvalue2_y : putvalue1_x ;

  // register toggle
  assign toggle$D_IN = ~toggle ;
  assign toggle$EN = WILL_FIRE_RL_rl_p3 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        toggle <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (toggle$EN) toggle <= `BSV_ASSIGNMENT_DELAY toggle$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    toggle = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkArbiter

