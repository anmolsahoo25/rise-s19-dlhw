//
// Generated by Bluespec Compiler, version 2018.10.beta1 (build e1df8052c, 2018-10-17)
//
// On Thu May 30 18:51:46 IST 2019
//
//
// Ports:
// Name                         I/O  size props
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkTop(CLK,
	     RST_N);
  input  CLK;
  input  RST_N;

  // register rg_cntr
  reg [31 : 0] rg_cntr;
  wire [31 : 0] rg_cntr$D_IN;
  wire rg_cntr$EN;

  // ports of submodule arb
  wire [31 : 0] arb$get, arb$putvalue1_x, arb$putvalue2_y;
  wire arb$EN_get, arb$EN_putvalue1, arb$EN_putvalue2, arb$RDY_get;

  // rule scheduling signals
  wire WILL_FIRE_RL_rl_cycle2out,
       WILL_FIRE_RL_rl_cycle3out,
       WILL_FIRE_RL_rl_cycle4out;

  // inputs to muxes for submodule ports
  wire MUX_arb$putvalue2_1__SEL_1;

  // declarations used by system tasks
  // synopsys translate_off
  reg [63 : 0] v__h275;
  reg [63 : 0] v__h341;
  reg [63 : 0] v__h425;
  reg [63 : 0] v__h495;
  // synopsys translate_on

  // submodule arb
  mkArbiter arb(.CLK(CLK),
		.RST_N(RST_N),
		.putvalue1_x(arb$putvalue1_x),
		.putvalue2_y(arb$putvalue2_y),
		.EN_putvalue1(arb$EN_putvalue1),
		.EN_putvalue2(arb$EN_putvalue2),
		.EN_get(arb$EN_get),
		.RDY_putvalue1(),
		.RDY_putvalue2(),
		.get(arb$get),
		.RDY_get(arb$RDY_get));

  // rule RL_rl_cycle2out
  assign WILL_FIRE_RL_rl_cycle2out = arb$RDY_get && rg_cntr == 32'd1 ;

  // rule RL_rl_cycle3out
  assign WILL_FIRE_RL_rl_cycle3out = arb$RDY_get && rg_cntr == 32'd2 ;

  // rule RL_rl_cycle4out
  assign WILL_FIRE_RL_rl_cycle4out = arb$RDY_get && rg_cntr == 32'd3 ;

  // inputs to muxes for submodule ports
  assign MUX_arb$putvalue2_1__SEL_1 = rg_cntr == 32'd2 || rg_cntr == 32'd1 ;

  // register rg_cntr
  assign rg_cntr$D_IN = rg_cntr + 32'd1 ;
  assign rg_cntr$EN = 1'd1 ;

  // submodule arb
  assign arb$putvalue1_x = 32'd1 ;
  assign arb$putvalue2_y = MUX_arb$putvalue2_1__SEL_1 ? 32'd2 : 32'd3 ;
  assign arb$EN_putvalue1 = MUX_arb$putvalue2_1__SEL_1 ;
  assign arb$EN_putvalue2 =
	     rg_cntr == 32'd2 || rg_cntr == 32'd1 || rg_cntr == 32'd3 ;
  assign arb$EN_get =
	     WILL_FIRE_RL_rl_cycle4out || WILL_FIRE_RL_rl_cycle3out ||
	     WILL_FIRE_RL_rl_cycle2out ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_cntr <= `BSV_ASSIGNMENT_DELAY 32'd0;
      end
    else
      begin
        if (rg_cntr$EN) rg_cntr <= `BSV_ASSIGNMENT_DELAY rg_cntr$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_cntr = 32'hAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (rg_cntr == 32'd0)
	begin
	  v__h275 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (rg_cntr == 32'd0) $display("%t starting", v__h275);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_cycle2out)
	begin
	  v__h341 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_cycle2out)
	$display("%t output = %0d", v__h341, arb$get);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_cycle3out)
	begin
	  v__h425 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_cycle3out)
	$display("%t output = %0d", v__h425, arb$get);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_cycle4out)
	begin
	  v__h495 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_cycle4out)
	$display("%t output = %0d", v__h495, arb$get);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_cycle4out) $finish(32'd1);
  end
  // synopsys translate_on
endmodule  // mkTop

