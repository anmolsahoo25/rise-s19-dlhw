//
// Generated by Bluespec Compiler, version 2018.10.beta1 (build e1df8052c, 2018-10-17)
//
// On Thu Jun 27 15:11:57 IST 2019
//
//
// Ports:
// Name                         I/O  size props
// rightoutput                    O    32 reg
// RDY_rightoutput                O     1 const
// RDY_upinput                    O     1 const
// downoutput                     O    32
// RDY_downoutput                 O     1 const
// RDY_leftinput                  O     1 const
// RDY_weightinp                  O     1 const
// weightoutput                   O    32 reg
// RDY_weightoutput               O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// upinput_y                      I    32 reg
// leftinput_x                    I    32 reg
// weightinp_w                    I    32 reg
// EN_upinput                     I     1
// EN_leftinput                   I     1
// EN_weightinp                   I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkPE(CLK,
	    RST_N,

	    rightoutput,
	    RDY_rightoutput,

	    upinput_y,
	    EN_upinput,
	    RDY_upinput,

	    downoutput,
	    RDY_downoutput,

	    leftinput_x,
	    EN_leftinput,
	    RDY_leftinput,

	    weightinp_w,
	    EN_weightinp,
	    RDY_weightinp,

	    weightoutput,
	    RDY_weightoutput);
  input  CLK;
  input  RST_N;

  // value method rightoutput
  output [31 : 0] rightoutput;
  output RDY_rightoutput;

  // action method upinput
  input  [31 : 0] upinput_y;
  input  EN_upinput;
  output RDY_upinput;

  // value method downoutput
  output [31 : 0] downoutput;
  output RDY_downoutput;

  // action method leftinput
  input  [31 : 0] leftinput_x;
  input  EN_leftinput;
  output RDY_leftinput;

  // action method weightinp
  input  [31 : 0] weightinp_w;
  input  EN_weightinp;
  output RDY_weightinp;

  // value method weightoutput
  output [31 : 0] weightoutput;
  output RDY_weightoutput;

  // signals for module outputs
  wire [31 : 0] downoutput, rightoutput, weightoutput;
  wire RDY_downoutput,
       RDY_leftinput,
       RDY_rightoutput,
       RDY_upinput,
       RDY_weightinp,
       RDY_weightoutput;

  // register rg_pixel
  reg [31 : 0] rg_pixel;
  wire [31 : 0] rg_pixel$D_IN;
  wire rg_pixel$EN;

  // register rg_psumi
  reg [31 : 0] rg_psumi;
  wire [31 : 0] rg_psumi$D_IN;
  wire rg_psumi$EN;

  // register rg_weight
  reg [31 : 0] rg_weight;
  wire [31 : 0] rg_weight$D_IN;
  wire rg_weight$EN;

  // remaining internal signals
  wire [63 : 0] rg_weight_MUL_rg_pixel___d4;
  wire [31 : 0] x_wget__h172;

  // value method rightoutput
  assign rightoutput = rg_pixel ;
  assign RDY_rightoutput = 1'd1 ;

  // action method upinput
  assign RDY_upinput = 1'd1 ;

  // value method downoutput
  assign downoutput = x_wget__h172 ;
  assign RDY_downoutput = 1'd1 ;

  // action method leftinput
  assign RDY_leftinput = 1'd1 ;

  // action method weightinp
  assign RDY_weightinp = 1'd1 ;

  // value method weightoutput
  assign weightoutput = rg_weight ;
  assign RDY_weightoutput = 1'd1 ;

  // register rg_pixel
  assign rg_pixel$D_IN = leftinput_x ;
  assign rg_pixel$EN = EN_leftinput ;

  // register rg_psumi
  assign rg_psumi$D_IN = upinput_y ;
  assign rg_psumi$EN = EN_upinput ;

  // register rg_weight
  assign rg_weight$D_IN = weightinp_w ;
  assign rg_weight$EN = EN_weightinp ;

  // remaining internal signals
  assign rg_weight_MUL_rg_pixel___d4 = rg_weight * rg_pixel ;
  assign x_wget__h172 = rg_psumi + rg_weight_MUL_rg_pixel___d4[31:0] ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_pixel <= `BSV_ASSIGNMENT_DELAY 32'd0;
	rg_psumi <= `BSV_ASSIGNMENT_DELAY 32'd0;
	rg_weight <= `BSV_ASSIGNMENT_DELAY 32'd0;
      end
    else
      begin
        if (rg_pixel$EN) rg_pixel <= `BSV_ASSIGNMENT_DELAY rg_pixel$D_IN;
	if (rg_psumi$EN) rg_psumi <= `BSV_ASSIGNMENT_DELAY rg_psumi$D_IN;
	if (rg_weight$EN) rg_weight <= `BSV_ASSIGNMENT_DELAY rg_weight$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_pixel = 32'hAAAAAAAA;
    rg_psumi = 32'hAAAAAAAA;
    rg_weight = 32'hAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkPE

